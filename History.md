## Update History

### 0.0.1

完成了CI的工作，CI为Continuous Integration即持续集成，很多初学者会选择在本地测试自己的代码，但是如果仅仅需要一个git push就可以部署到自己的服务器上，然后开始使用那不也可以直接在服务器上测试么？当然，要说速度还是代码运行完直接监听localhost的一个端口测试来得快些。但是这个步骤等到日后有了上线版本之后就变得很有必要了，难道每次更新都还要把代码或者文件夹粘贴到服务器上么？

由于使用了go语言以及docker作为开发环境，加之本项目的开源特性，我使用了[Semaphore](https://semaphoreci.com)作为CI的工具。

当然我这里不会讲如何使用Semaphore，而是希望说一下我通过集成CI环境这个过程对go语言和docker原理的一点理解。

以下的观点只是适合和我一样是后端完全新手，都不知道后端程序如何工作的读者看的。

首先说一下CI的流程:
1. Semaphore会监测我们选定的代码仓库(这里选择的是github)的一个分支
2. 我们在本地写完代码并运行git push指令
3. Semaphore监测到了push的动作，会主动请求把代码拿过来，然后按照我们设定好编译代码先行编译（如果代码结构不复杂例如文件夹下就是main.go则可以直接使用默认代码，如果代码结构稍微多一点，例如我们这个项目，则就需要修改go build命令的参数来让命令可以正确找到main.go）
4. 编译通过，开始部署（如果选择了自动部署的话）
5. 按照部署指令，再次编译代码，然后运行docker build打包docker
6. 将打包好的docker image push到之前选择的docker仓库中
7. 进入服务器，运行已经写好的.sh脚本文件，拉取新镜像并运行docker run命令。
8. 部署完成。

然后来说下我认为的知识点：
1. 首先是go语言，go get获取编译所需的package，然后go build编译出go程序，这是最基本的允许go程序的方法。
2. 其次是docker，首先docker只是一种容器（container）技术，尽管很多人一提容器就会想到docker，但并非docker发明了容器，只是将其简单化了。
3. 容器的基本概念：容器可以类比为一个超小型的虚拟机(VM)，它拥有着能够让后端程序跑起来所需要的所有环境但同时其并不是一个完整的系统，在docker的容器理念中，一个容器仅仅会运行一个程序。至于为什么要学习容器技术，请自行Google。
4. 我们依赖Dockerfile运行的docker build命令，并不是生成了容器，而是生成了一个镜像(image)，通过后续的docker run命令才会生成一个容器。
5. docker其实会把镜像细分成很多部分，例如golang的包, 肯定包含了系统环境包，例如ubantu，然后包括了go语言运行环境包，我们再依据这个golang的包，打包一个包含beego的程序的包，再打包我们自己的程序。这样做用什么好处呢？每个部分都会细分成一个包，都有自己唯一的sha1编码（同一个包不同版本的编码也会不同，所以说唯一），而docker pull的时候，docker会检查本地已经存在的包，并不是大包，而是所有细分的小包，已经存在本地的验证过sha1编码之后便不会再次重复下载，所以在每个服务器的docker环境里留下基础镜像就会节省很多流量和时间，在当前国内的墙的环境下，docker pull的速度尤其的慢，这一点就变得很有必要了。
6. 为什么拉取的新镜像直接run就可以运行程序？因为我们在生成容器的Dockerfile中已经在生成镜像的同时将我们的程序复制到了镜像中同时指定了程序的工作环境，当然我们在docker run命令中可以直接复制程序到容器中。
7. 第五点是依赖Semaphore的预编译环境支持docker命令来做到的，如果选择的CI平台不支持docker环境呢，那么按照我的设想步骤，在部署步骤中可以直接跳过打包docker的步骤，直接进入服务器，而在.sh脚本中加入从git pull代码并编译的步骤，然后加入docker build命令或者认为不需要修改编译环境则直接用docker run命令复制新程序到新容器中并删除旧容器完成部署。
8. 至于Dockerfile中指令的含义，请自行搜索学习。如果有对部署指令集或者服务器端update.sh的需求，我也会考虑后续补上，但其实其中也只是一些最基本的build、run命令而已。

## 0.0.2
### 架构方面
使用了beego推荐的架构，即MVC，自然后台程序不会如前端程序那样可以明显的细分为清楚的model-view-controller,但model和controller是清晰的，毕竟有数据就得有model，有调度就得有controller，而我这里另一个封装的包，我选择了起名为service，即服务。在我认为的架构里面，model应该是最高位的，不论controller还是service都需要依赖model包，毕竟后端就是和网络和数据打交道，model不应该依赖其他的包，仅仅依赖基础包就应该可以完全工作才是对的，在model里我不仅仅只是声明了对象，更重要的是提供对象的变量相关方法，处理数据的生成和封装打包的问题。而service，其实在所做的事情的层面上比model还要更底层，service是去和数据库读写打交道的，而以后扩展到例如定时清理token值的任务等等，service基于model为controller提供服务，这是我的基本思想。
### 数据库
这个版本里面可以看到我刚刚开了MySQL的一个非常非常小的头，但其实仔细看看会发现我已经用redis写完了user相关的服务了。不错，原本我就是打算要用redis做持久化存储的，有人会说redis占用内存太大，不适合做持久化，但其实redis的开发者早就注意到了这个问题，在最近的版本中也是开发了自己的持久化方案，即冷热分离，当内存占用较高的时候，会将原本存在内存中的较旧的内容存储到硬盘中。
但最后为什么还是选择了MySQL做持久化呢？其实最最原本我还是打算用MySQL的，redis是用来做缓存的，但无奈我本机之前装过MySQL环境，无论如何都卸载不干净，导致MySQL无法本地调试，所以才去寻找redis做持久化存储的可能性，当然最开始还是受了比较大的打击的，但后来还是找到了原来redis已经原生支持了冷热分离，可是想想这终归不是自己动手来做的事情，总是觉得不靠谱，最后还是花了点精力去解决了MySQL的问题，具体解决办法在这里[Mac如何完全卸载MySQL](http://blog.swiftflamel.com/2017/04/17/macos%E5%BD%BB%E5%BA%95%E5%8D%B8%E8%BD%BDmysql/)
所以最终我们的后端数据架构就会变成了由redis做缓存，MySQL做持久化存储的结构，而数据读写的想法就是先读redis，redis中不存在的话，去读MySQL，读到的结果返回给controller处理的同时也会存到redis中，而在redis的数据库中则会加入计数器，一旦计数器超限在存入新数据的同时会删除旧的缓存。
不同于MySQL，go语言的redis库并没有提供连接池，我在代码里也参考网上的代码简单修改实现了一个，确保初级性能需求的处理

